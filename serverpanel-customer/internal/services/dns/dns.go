package dns

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

// Manager handles DNS zone operations
type Manager struct {
	simulateMode bool
	basePath     string
	nameservers  []string
}

// ZoneConfig contains DNS zone configuration
type ZoneConfig struct {
	Domain      string
	IPAddress   string   // Server IP
	MXRecords   []string // Mail servers
	Nameservers []string // ns1.example.com, ns2.example.com
	TTL         int
}

// NewManager creates a new DNS manager
func NewManager(simulateMode bool, basePath string) *Manager {
	return &Manager{
		simulateMode: simulateMode,
		basePath:     basePath,
		nameservers:  []string{"ns1.serverpanel.local", "ns2.serverpanel.local"},
	}
}

func (m *Manager) GetZonePath() string {
	if m.simulateMode {
		return filepath.Join(m.basePath, "bind", "zones")
	}
	return "/etc/bind/zones"
}

func (m *Manager) GetConfigPath() string {
	if m.simulateMode {
		return filepath.Join(m.basePath, "bind")
	}
	return "/etc/bind"
}

// CreateZone creates a DNS zone for a domain
func (m *Manager) CreateZone(config ZoneConfig) error {
	if config.TTL == 0 {
		config.TTL = 3600
	}

	if config.IPAddress == "" {
		config.IPAddress = "127.0.0.1" // Will be replaced with actual server IP
	}

	if len(config.Nameservers) == 0 {
		config.Nameservers = m.nameservers
	}

	// Create zone file
	zoneContent := m.generateZoneFile(config)

	zonePath := m.GetZonePath()
	if err := os.MkdirAll(zonePath, 0755); err != nil {
		return fmt.Errorf("failed to create zone directory: %w", err)
	}

	zoneFile := filepath.Join(zonePath, "db."+config.Domain)
	if err := os.WriteFile(zoneFile, []byte(zoneContent), 0644); err != nil {
		return fmt.Errorf("failed to write zone file: %w", err)
	}

	log.Printf("üìù DNS zone created: %s", zoneFile)

	// Add zone to named.conf.local
	if err := m.addZoneToConfig(config.Domain, zoneFile); err != nil {
		return err
	}

	return m.Reload()
}

func (m *Manager) generateZoneFile(config ZoneConfig) string {
	serial := time.Now().Format("2006010215") // YYYYMMDDNN format

	zone := fmt.Sprintf(`; Zone file for %s
; Generated by ServerPanel
$TTL %d
@       IN      SOA     %s. hostmaster.%s. (
                        %s      ; Serial
                        3600            ; Refresh
                        1800            ; Retry
                        604800          ; Expire
                        86400 )         ; Minimum TTL

; Nameservers
`, config.Domain, config.TTL, config.Nameservers[0], config.Domain, serial)

	// Add NS records
	for _, ns := range config.Nameservers {
		zone += fmt.Sprintf("@       IN      NS      %s.\n", ns)
	}

	// Add A records
	zone += fmt.Sprintf(`
; A Records
@       IN      A       %s
www     IN      A       %s
mail    IN      A       %s
ftp     IN      A       %s

; CNAME Records
webmail IN      CNAME   mail
`, config.IPAddress, config.IPAddress, config.IPAddress, config.IPAddress)

	// Add MX records
	if len(config.MXRecords) > 0 {
		zone += "\n; MX Records\n"
		for i, mx := range config.MXRecords {
			priority := (i + 1) * 10
			zone += fmt.Sprintf("@       IN      MX      %d      %s.\n", priority, mx)
		}
	} else {
		zone += fmt.Sprintf("\n; MX Records\n@       IN      MX      10      mail.%s.\n", config.Domain)
	}

	// Add TXT records for SPF and DMARC
	zone += fmt.Sprintf(`
; TXT Records - Mail Security
; SPF Record
@       IN      TXT     "v=spf1 a mx ip4:%s ~all"

; DMARC Record
_dmarc  IN      TXT     "v=DMARC1; p=none; rua=mailto:postmaster@%s"

; DKIM Record placeholder (will be updated when DKIM key is generated)
; default._domainkey IN TXT "v=DKIM1; k=rsa; p=..."
`, config.IPAddress, config.Domain)

	return zone
}

func (m *Manager) addZoneToConfig(domain, zoneFile string) error {
	zoneEntry := fmt.Sprintf(`
zone "%s" {
    type master;
    file "%s";
    allow-transfer { none; };
};
`, domain, zoneFile)

	configPath := filepath.Join(m.GetConfigPath(), "named.conf.local")

	// Append to config file
	f, err := os.OpenFile(configPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("failed to open named.conf.local: %w", err)
	}
	defer f.Close()

	if _, err := f.WriteString(zoneEntry); err != nil {
		return fmt.Errorf("failed to write zone entry: %w", err)
	}

	log.Printf("üìù Zone added to named.conf.local: %s", domain)
	return nil
}

// DeleteZone removes a DNS zone
func (m *Manager) DeleteZone(domain string) error {
	zoneFile := filepath.Join(m.GetZonePath(), "db."+domain)
	if err := os.Remove(zoneFile); err != nil && !os.IsNotExist(err) {
		log.Printf("Warning: failed to remove zone file: %v", err)
	}

	log.Printf("üóëÔ∏è DNS zone deleted: %s", domain)
	// Note: In production, we'd also need to remove the zone from named.conf.local
	return m.Reload()
}

// Reload reloads BIND
func (m *Manager) Reload() error {
	if m.simulateMode {
		log.Printf("üîß [SIM√úLASYON] named-checkconf && systemctl reload bind9")
		return nil
	}

	// Check config
	cmd := exec.Command("named-checkconf")
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("named config check failed: %s - %w", string(output), err)
	}

	// Reload
	cmd = exec.Command("systemctl", "reload", "bind9")
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to reload bind9: %s - %w", string(output), err)
	}

	log.Printf("‚úÖ BIND reloaded successfully")
	return nil
}

// AddRecord adds a DNS record to an existing zone
func (m *Manager) AddRecord(domain, recordType, name, value string, ttl int) error {
	zoneFile := filepath.Join(m.GetZonePath(), "db."+domain)

	// Check if zone file exists
	if _, err := os.Stat(zoneFile); os.IsNotExist(err) {
		return fmt.Errorf("zone file not found: %s", zoneFile)
	}

	// Read existing zone file
	content, err := os.ReadFile(zoneFile)
	if err != nil {
		return fmt.Errorf("failed to read zone file: %w", err)
	}

	// Check if record already exists
	if strings.Contains(string(content), name+"\tIN\t") || strings.Contains(string(content), name+" IN ") {
		log.Printf("‚ö†Ô∏è DNS record already exists: %s.%s", name, domain)
		return nil
	}

	// Append new record
	newRecord := fmt.Sprintf("\n%s\tIN\t%s\t%s\n", name, recordType, value)
	f, err := os.OpenFile(zoneFile, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("failed to open zone file: %w", err)
	}
	defer f.Close()

	if _, err := f.WriteString(newRecord); err != nil {
		return fmt.Errorf("failed to write record: %w", err)
	}

	log.Printf("üìù DNS record added: %s.%s %s %s", name, domain, recordType, value)
	return m.Reload()
}
