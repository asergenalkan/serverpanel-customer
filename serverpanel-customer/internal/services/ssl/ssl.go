package ssl

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"time"
)

// Manager handles SSL certificate operations
type Manager struct {
	simulateMode bool
	basePath     string
	webRoot      string
	email        string
}

// CertConfig contains SSL certificate configuration
type CertConfig struct {
	Domain  string
	Aliases []string // Additional domains (www.example.com)
	WebRoot string   // Document root for webroot verification
	Email   string   // Admin email for Let's Encrypt
	KeySize int
}

// CertInfo contains certificate information
type CertInfo struct {
	Domain     string
	Issuer     string
	ValidFrom  time.Time
	ValidUntil time.Time
	CertPath   string
	KeyPath    string
}

// NewManager creates a new SSL manager
func NewManager(simulateMode bool, basePath string) *Manager {
	return &Manager{
		simulateMode: simulateMode,
		basePath:     basePath,
		email:        os.Getenv("LETSENCRYPT_EMAIL"),
	}
}

func (m *Manager) GetCertPath() string {
	if m.simulateMode {
		return filepath.Join(m.basePath, "ssl", "certs")
	}
	return "/etc/letsencrypt/live"
}

// IssueCertificate obtains an SSL certificate from Let's Encrypt
func (m *Manager) IssueCertificate(config CertConfig) (*CertInfo, error) {
	if config.Email == "" {
		config.Email = m.email
	}
	if config.Email == "" {
		config.Email = "admin@" + config.Domain
	}

	if m.simulateMode {
		return m.simulateIssueCertificate(config)
	}

	return m.realIssueCertificate(config)
}

func (m *Manager) simulateIssueCertificate(config CertConfig) (*CertInfo, error) {
	certDir := filepath.Join(m.GetCertPath(), config.Domain)
	os.MkdirAll(certDir, 0700)

	// Create dummy certificate files
	certPath := filepath.Join(certDir, "fullchain.pem")
	keyPath := filepath.Join(certDir, "privkey.pem")

	certContent := fmt.Sprintf(`-----BEGIN CERTIFICATE-----
SIMULATED CERTIFICATE FOR %s
Generated by ServerPanel (Development Mode)
This is NOT a real SSL certificate
-----END CERTIFICATE-----
`, config.Domain)

	keyContent := `-----BEGIN PRIVATE KEY-----
SIMULATED PRIVATE KEY
This is NOT a real private key
-----END PRIVATE KEY-----
`

	os.WriteFile(certPath, []byte(certContent), 0600)
	os.WriteFile(keyPath, []byte(keyContent), 0600)

	log.Printf("üîß [SIM√úLASYON] certbot certonly --webroot -w %s -d %s -d www.%s --email %s --agree-tos",
		config.WebRoot, config.Domain, config.Domain, config.Email)
	log.Printf("üìù SSL certificate created: %s", certPath)

	return &CertInfo{
		Domain:     config.Domain,
		Issuer:     "ServerPanel (Simulated)",
		ValidFrom:  time.Now(),
		ValidUntil: time.Now().AddDate(0, 3, 0), // 90 days
		CertPath:   certPath,
		KeyPath:    keyPath,
	}, nil
}

func (m *Manager) realIssueCertificate(config CertConfig) (*CertInfo, error) {
	// Build certbot command
	args := []string{
		"certonly",
		"--webroot",
		"-w", config.WebRoot,
		"-d", config.Domain,
		"--email", config.Email,
		"--agree-tos",
		"--non-interactive",
	}

	// Add aliases
	for _, alias := range config.Aliases {
		args = append(args, "-d", alias)
	}

	cmd := exec.Command("certbot", args...)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("certbot failed: %s - %w", string(output), err)
	}

	certPath := filepath.Join("/etc/letsencrypt/live", config.Domain, "fullchain.pem")
	keyPath := filepath.Join("/etc/letsencrypt/live", config.Domain, "privkey.pem")

	log.Printf("‚úÖ SSL certificate issued for: %s", config.Domain)

	return &CertInfo{
		Domain:     config.Domain,
		Issuer:     "Let's Encrypt",
		ValidFrom:  time.Now(),
		ValidUntil: time.Now().AddDate(0, 3, 0),
		CertPath:   certPath,
		KeyPath:    keyPath,
	}, nil
}

// RenewCertificate renews an existing certificate
func (m *Manager) RenewCertificate(domain string) error {
	if m.simulateMode {
		log.Printf("üîß [SIM√úLASYON] certbot renew --cert-name %s", domain)
		return nil
	}

	cmd := exec.Command("certbot", "renew", "--cert-name", domain)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("certbot renew failed: %s - %w", string(output), err)
	}

	log.Printf("‚úÖ SSL certificate renewed for: %s", domain)
	return nil
}

// RevokeCertificate revokes and deletes a certificate
func (m *Manager) RevokeCertificate(domain string) error {
	if m.simulateMode {
		log.Printf("üîß [SIM√úLASYON] certbot revoke --cert-name %s --delete-after-revoke", domain)
		certDir := filepath.Join(m.GetCertPath(), domain)
		os.RemoveAll(certDir)
		return nil
	}

	cmd := exec.Command("certbot", "revoke", "--cert-name", domain, "--delete-after-revoke", "--non-interactive")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("certbot revoke failed: %s - %w", string(output), err)
	}

	log.Printf("üóëÔ∏è SSL certificate revoked: %s", domain)
	return nil
}

// GetCertificateInfo returns information about an existing certificate
func (m *Manager) GetCertificateInfo(domain string) (*CertInfo, error) {
	certPath := filepath.Join(m.GetCertPath(), domain, "fullchain.pem")
	keyPath := filepath.Join(m.GetCertPath(), domain, "privkey.pem")

	if _, err := os.Stat(certPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("certificate not found for domain: %s", domain)
	}

	// In production, we would parse the certificate to get actual dates
	return &CertInfo{
		Domain:     domain,
		Issuer:     "Let's Encrypt",
		ValidFrom:  time.Now().AddDate(0, -1, 0),
		ValidUntil: time.Now().AddDate(0, 2, 0),
		CertPath:   certPath,
		KeyPath:    keyPath,
	}, nil
}

// SetupAutoRenewal sets up automatic certificate renewal via cron
func (m *Manager) SetupAutoRenewal() error {
	if m.simulateMode {
		log.Printf("üîß [SIM√úLASYON] Added cron job: 0 0 * * * certbot renew --quiet")
		return nil
	}

	// Add to system crontab
	cronEntry := "0 0 * * * root certbot renew --quiet --post-hook 'systemctl reload apache2 nginx'\n"
	cronFile := "/etc/cron.d/certbot-renew"

	if err := os.WriteFile(cronFile, []byte(cronEntry), 0644); err != nil {
		return fmt.Errorf("failed to setup auto-renewal: %w", err)
	}

	log.Printf("‚úÖ SSL auto-renewal configured")
	return nil
}
